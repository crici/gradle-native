buildscript {
	repositories {
		mavenCentral()
		maven { url = 'subprojects/distributions/build/repository' }
		maven { url = 'https://repo.nokee.dev/snapshot' }
		maven { url = 'https://repo.nokee.dev/release' }
	}
	dependencies {
		classpath 'dev.gradleplugins:documentation-kit:latest.integration'
		classpath 'org.apache.maven:maven-repository-metadata:3.6.3'
	}
}

import org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Reader
import org.codehaus.plexus.util.xml.pull.XmlPullParserException
import org.gradle.util.VersionNumber

import java.util.stream.Collectors

import static dev.gradleplugins.GradleRuntimeCompatibility.*

class Version {
	private VersionNumber delegate = null
	private final ProjectLayout projectLayout

	Version(ProjectLayout projectLayout) {
		this.projectLayout = projectLayout
	}

	VersionNumber getBaseVersion() {
		maybeLoad()
		return delegate.baseVersion
	}

	java.util.Optional<String> getQualifier() {
		maybeLoad()
		return java.util.Optional.ofNullable(delegate.qualifier)
	}

	@Override
	String toString() {
		maybeLoad()
		return delegate.toString()
	}

	private void maybeLoad() {
		if (delegate == null) {
			if (System.getProperties().containsKey("release")) {
				delegate = VersionNumber.parse(loadBaseVersion())
			} else if (System.getProperties().containsKey('milestone')) {
				def latestRelease = get(new URL('https://repo.nokee.dev/release/dev/nokee/distributions/maven-metadata.xml')).stream().max(Comparator.naturalOrder()).orElse(VersionNumber.parse('0.4.0'))
				delegate = new VersionNumber(latestRelease.major, latestRelease.minor, latestRelease.micro + 1, null)
			} else {
				delegate = VersionNumber.parse("${loadBaseVersion()}-${loadQualifier()}")
			}
		}
	}

	private List<VersionNumber> get(URL url) {
		try {
			def connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("GET");
			connection.setRequestProperty("User-Agent", "non-empty")
			connection.connect();
			if (connection.getResponseCode() == 200) {
				try {
					// TODO: Make sure distributions also also not a milestone release
					return new MetadataXpp3Reader().read(connection.getInputStream()).getVersioning().getVersions().stream().map { VersionNumber.parse(it) }.collect(Collectors.toList())
				} catch (IOException | XmlPullParserException e) {
					throw new RuntimeException(e);
				}
			} else if (connection.getResponseCode() == 404) {
				return Collections.emptyList()
			}
			throw new RuntimeException("Receive '" + connection.getResponseCode() + "' with message '" + connection.getResponseMessage() + "' for url '" + url.toString() + "'.");
		} catch (IOException e) {
			throw new java.io.UncheckedIOException(e);
		}
	}

	private String loadBaseVersion() {
		return projectLayout.projectDirectory.file('version.txt').asFile.text.trim()
	}

	private String loadQualifier() {
		// CI macOS is using a version that prompt a shorter value by 1 char... Tabar...
		def process = "git rev-parse --short=8 HEAD".execute(null, projectLayout.projectDirectory.asFile)
		process.waitFor()
		def result = process.in.text.trim()
		return result
	}
}

def v = new Version(layout)
allprojects {
	version = v
	group = 'dev.nokee'
}

// Cleans $buildDir/tmp/test files on project check
subprojects {
	plugins.withType(LifecycleBasePlugin) {
		def cleanTestFiles = tasks.register('cleanTestFiles', Delete) {
			delete(layout.buildDirectory.file('tmp/test files'))
		}

		tasks.withType(Test).configureEach {
			mustRunAfter(cleanTestFiles)
		}

		tasks.named(LifecycleBasePlugin.CHECK_TASK_NAME) {
			dependsOn cleanTestFiles
		}
	}
}

// Configure gradlePlugin
subprojects {
	pluginManager.withPlugin('dev.gradleplugins.java-gradle-plugin') {
		gradlePlugin {
			compatibility {
				minimumGradleVersion = project.minimumGradleVersion
			}
			java {
				withJavadocJar()
				withSourcesJar()
			}
		}
	}
	pluginManager.withPlugin('java-library') {
		java {
			sourceCompatibility = minimumJavaVersionFor(minimumGradleVersion)
			targetCompatibility = minimumJavaVersionFor(minimumGradleVersion)
		}
	}
}

// Configure functionalTest
subprojects {
	pluginManager.withPlugin('dev.gradleplugins.java-gradle-plugin') {
		apply plugin: 'dev.gradleplugins.gradle-plugin-functional-test'
		functionalTest {
			testingStrategies = [strategies.coverageForMinimumVersion, strategies.coverageForLatestGlobalAvailableVersion, strategies.coverageForLatestNightlyVersion]
			dependencies {
				implementation project(':internalTesting')
				implementation spockFramework()
				implementation gradleFixtures()
			}
		}
	}
}

// Configure test for java-gradle-plugin
subprojects {
	pluginManager.withPlugin('dev.gradleplugins.java-gradle-plugin') {
		apply plugin: 'dev.gradleplugins.gradle-plugin-unit-test'
		test {
			dependencies {
				implementation project(':internalTesting')
				implementation spockFramework()
				implementation groovy()
			}
		}
	}
}

// Configure test for java-library
subprojects {
	pluginManager.withPlugin('java-library') {
		dependencies {
			testImplementation project(':internalTesting')
		}
	}
}

// Configure JUnit 5 compatibility
subprojects {
	tasks.withType(Test).configureEach { it.useJUnitPlatform() }
}

// Enable lombok on all subprojects
subprojects { project ->
	def addLombokDependency = { Configuration configuration ->
		project.dependencies.add(configuration.name, "org.projectlombok:lombok:${lombokVersion}" as String)
	}
	configurations.matching { it.name.toLowerCase().endsWith('compileonly') }.all(addLombokDependency)
	configurations.matching { it.name.toLowerCase().endsWith('annotationprocessor') }.all(addLombokDependency)
}

// Configure general artifact repositories
subprojects {
	repositories {
		mavenCentral()
		gradlePluginDevelopment()
	}
}

// Configure Documentation
subprojects { prj ->
	if (prj.name == 'internalTesting') {
		return; // skip
	}
	pluginManager.apply('dev.gradleplugins.documentation.dsl-reference')
	pluginManager.apply('dev.gradleplugins.documentation.api-reference')
	pluginManager.apply('dev.gradleplugins.documentation.javadoc-render')
	prj.configurations.matching { it.name == 'implementation' }.all { implementation ->
		prj.extensions.components.apiReference {
			dependencies.api.asConfiguration.extendsFrom(implementation)
		}
	}
	prj.configurations.matching { it.name == 'compileOnly' }.all { compileOnly ->
		prj.extensions.components.apiReference {
			dependencies.api.asConfiguration.extendsFrom(compileOnly)
		}
	}
	tasks.named('generateDslReference') {
		templateFile = rootProject.file('subprojects/docs/src/docs/dsl/dsl.template')
	}
}

// Configure publishing to Nokee
subprojects { prj ->
	if (prj == project(':docs')) {
		return // ignore this configuration
	}
	pluginManager.withPlugin('maven-publish') {
		// Register Nokee repositories
		publishing {
			repositories {
				maven {
					name = 'nokeeRelease'
					url = providers.gradleProperty("${name}Url").forUseAtConfigurationTime().orElse('')
					credentials(AwsCredentials)
				}
				maven {
					name = 'nokeeSnapshot'
					url = providers.gradleProperty("${name}Url").forUseAtConfigurationTime().orElse('')
					credentials(AwsCredentials)
				}
			}
		}

		// Prevent publishing mistakes
		prj.tasks.withType(PublishToMavenRepository).configureEach {
			doFirst {
				if (repository.name == 'nokeeRelease' && publication.version.contains('-')) {
					throw new UnsupportedOperationException('Please publish snapshot artifacts in snapshot repository')
				} else if (repository.name == 'nokeeSnapshot' && !publication.version.contains('-')) {
					throw new UnsupportedOperationException('Please publish release artifacts in release repository')
				}
			}
			doLast {
				println "Published version ${publication.version}"
			}
		}

		// Register lifecycle task to publish into Nokee repositories
		prj.tasks.register('publishToNokee') {
			dependsOn({
				if (prj.version.toString().contains('-')) {
					return ['publishAllPublicationsToNokeeSnapshotRepository']
				}
				return ['publishAllPublicationsToNokeeReleaseRepository']
			})
		}
	}
}
// Add lifecycle task to print the published version
tasks.register('publishAllPublicationsToNokeeSnapshotRepository') {
	doLast {
		println "Published version ${project.version}"
	}
}
tasks.register('publishAllPublicationsToNokeeReleaseRepository') {
	doLast {
		println "Published version ${project.version}"
	}
}
